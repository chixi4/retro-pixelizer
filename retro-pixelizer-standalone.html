<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Retro Pixelizer - 复古像素化工具</title>
  <style>
/* CSS Variables for Light/Dark Theme */
:root {
  --bg: #ffffff;
  --fg: #000000;
  --border: #000000;
  --muted: #666666;
  --panel-bg: #f5f5f5;
  --hover-bg: #e0e0e0;
}

[data-theme="dark"] {
  --bg: #0a0a0a;
  --fg: #ffffff;
  --border: #ffffff;
  --muted: #999999;
  --panel-bg: #1a1a1a;
  --hover-bg: #2a2a2a;
}

/* Reset */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Base */
body {
  font-family: "Courier New", "Liberation Mono", monospace;
  font-size: 14px;
  line-height: 1.5;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
}

/* Page Layout */
.page {
  max-width: 1200px;
  margin: 0 auto;
  padding: 16px;
}

/* Header */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 12px;
  border-bottom: 2px solid var(--border);
  margin-bottom: 16px;
}

.title {
  font-size: 24px;
  font-weight: bold;
  letter-spacing: 2px;
}

.theme-btn {
  font-family: inherit;
  font-size: 12px;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--fg);
  padding: 4px 8px;
  cursor: pointer;
}

.theme-btn:hover {
  background: var(--fg);
  color: var(--bg);
}

/* Main Layout */
.main {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* Panel */
.panel {
  border: 2px solid var(--border);
  padding: 16px;
  background: var(--panel-bg);
}

/* Form Groups */
.form-group {
  margin-bottom: 16px;
}

.form-group:last-of-type {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  font-weight: bold;
  margin-bottom: 6px;
}

/* Upload Area */
.upload-area {
  border: 2px dashed var(--border);
  padding: 40px;
  text-align: center;
  cursor: pointer;
  background: var(--bg);
  transition: background 0.15s;
}

.upload-area:hover {
  background: var(--hover-bg);
}

.upload-area.dragover {
  background: var(--hover-bg);
  border-style: solid;
}

.upload-text {
  font-size: 14px;
  color: var(--muted);
}

/* Input Styles */
input[type="range"],
input[type="file"],
input[type="number"],
select {
  font-family: inherit;
  font-size: 14px;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  padding: 8px;
}

input[type="range"] {
  width: 100%;
  max-width: 300px;
}

select {
  width: 100%;
  cursor: pointer;
}

/* Dither Buttons */
.dither-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.dither-btn {
  font-family: inherit;
  font-size: 13px;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  padding: 8px 16px;
  cursor: pointer;
  transition: all 0.15s;
  flex: 0 0 auto;
}

.dither-btn:hover {
  background: var(--hover-bg);
}

.dither-btn.active {
  background: var(--fg);
  color: var(--bg);
  font-weight: bold;
}

/* Palette Buttons */
.palette-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  padding-bottom: 4px;
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--bg);
}

.palette-buttons::-webkit-scrollbar {
  height: 6px;
}

.palette-buttons::-webkit-scrollbar-track {
  background: var(--bg);
}

.palette-buttons::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 3px;
}

.palette-buttons::-webkit-scrollbar-thumb:hover {
  background: var(--fg);
}

.palette-btn {
  font-family: inherit;
  font-size: 13px;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  padding: 8px 16px;
  cursor: pointer;
  transition: all 0.15s;
  flex: 0 0 auto;
  white-space: nowrap;
}

.palette-btn:hover {
  background: var(--hover-bg);
}

.palette-btn.active {
  background: var(--fg);
  color: var(--bg);
  font-weight: bold;
}

.input-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.value-display {
  min-width: 60px;
  font-weight: bold;
}

/* Buttons */
.generate-btn {
  font-family: inherit;
  font-size: 16px;
  font-weight: bold;
  background: var(--fg);
  color: var(--bg);
  border: 2px solid var(--border);
  padding: 10px 24px;
  cursor: pointer;
  transition: all 0.15s;
  margin-right: 8px;
}

.generate-btn:hover:not(:disabled) {
  background: var(--bg);
  color: var(--fg);
}

.generate-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Status */
.status {
  margin-left: 12px;
  font-size: 12px;
  color: var(--muted);
}

.status.error {
  color: #cc0000;
}

[data-theme="dark"] .status.error {
  color: #ff4444;
}

/* Preview Section */
.preview-section {
  border: 2px solid var(--border);
  padding: 16px;
  background: var(--panel-bg);
}

.preview-header {
  font-weight: bold;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.preview-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}

.preview-box {
  text-align: center;
}

.preview-label {
  font-size: 12px;
  font-weight: bold;
  margin-bottom: 8px;
  color: var(--muted);
}

canvas {
  max-width: 100%;
  border: 2px solid var(--border);
  background: var(--bg);
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

/* Palette Preview */
.palette-preview {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  padding: 12px;
  border: 1px solid var(--border);
  background: var(--bg);
}

.palette-preview:empty {
  display: none;
}

.palette-color {
  width: 32px;
  height: 32px;
  border: 1px solid var(--border);
  cursor: pointer;
  position: relative;
}

.palette-color:hover::after {
  content: attr(data-hex);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--fg);
  color: var(--bg);
  padding: 2px 6px;
  font-size: 10px;
  white-space: nowrap;
  z-index: 10;
}

/* Footer */
.footer {
  margin-top: 24px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  text-align: center;
  font-size: 12px;
  color: var(--muted);
}

/* Responsive */
@media (max-width: 600px) {
  .page {
    padding: 12px;
  }

  .title {
    font-size: 20px;
  }

  .panel {
    padding: 12px;
  }

  .preview-container {
    grid-template-columns: 1fr;
  }

  .preview-container > div:first-child {
    display: none;
  }

  .generate-btn {
    width: 100%;
    margin-bottom: 8px;
  }

  .dither-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
  }

  .dither-btn {
    font-size: 12px;
    padding: 6px 12px;
  }

  .palette-btn {
    font-size: 12px;
    padding: 6px 12px;
  }

  .input-row {
    flex-wrap: wrap;
  }

  input[type="number"] {
    width: 80px;
  }

  .form-group label {
    font-size: 13px;
  }
}
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="title">Retro Pixelizer</h1>
      <div class="header-right">
        <button id="themeToggle" class="theme-btn" title="切换亮/暗模式">[亮/暗]</button>
      </div>
    </header>

    <main class="main">
      <section class="panel">
        <div class="form-group">
          <label>图片上传:</label>
          <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" accept="image/*" hidden>
            <div class="upload-text">点击或拖拽图片到此处</div>
          </div>
        </div>

        <div class="form-group">
          <label for="targetWidth">目标宽度 (像素):</label>
          <div class="input-row">
            <input type="range" id="targetWidth" min="32" max="512" value="128" step="8">
            <input type="number" id="targetWidthNumber" min="32" max="512" value="128" step="8" style="width: 80px;">
            <span id="widthValue" class="value-display">px</span>
          </div>
        </div>

        <div class="form-group">
          <label>抖动算法:</label>
          <div class="dither-buttons" id="ditherButtons">
            <button class="dither-btn" data-algo="none">无抖动</button>
            <button class="dither-btn" data-algo="bayer-4x4">Bayer 4x4</button>
            <button class="dither-btn" data-algo="bayer-8x8">Bayer 8x8</button>
            <button class="dither-btn active" data-algo="floyd-steinberg">Floyd-Steinberg</button>
            <button class="dither-btn" data-algo="random">随机抖动</button>
          </div>
        </div>

        <div class="form-group">
          <label>调色板:</label>
          <div class="palette-buttons" id="paletteButtons">
            <button class="palette-btn active" data-palette="oil-6">Oil 6</button>
            <button class="palette-btn" data-palette="slso8">SLSO8</button>
            <button class="palette-btn" data-palette="blessing">Blessing</button>
            <button class="palette-btn" data-palette="nyx8">Nyx8</button>
            <button class="palette-btn" data-palette="ammo-8">Ammo-8</button>
            <button class="palette-btn" data-palette="dreamscape8">Dreamscape8</button>
            <button class="palette-btn" data-palette="ink">Ink</button>
            <button class="palette-btn" data-palette="dream-haze-8">Dream Haze 8</button>
            <button class="palette-btn" data-palette="aap-64">AAP-64</button>
            <button class="palette-btn" data-palette="blk-nx64">BLK NX64</button>
            <button class="palette-btn" data-palette="custom">自定义...</button>
          </div>
        </div>

        <div class="form-group" id="customPaletteGroup" style="display: none;">
          <label>上传调色板文件 (.hex / .gpl):</label>
          <input type="file" id="paletteFile" accept=".hex,.gpl,.txt">
        </div>

        <div class="form-group">
          <button id="downloadBtn" class="generate-btn" disabled>[下载图片]</button>
          <span id="status" class="status"></span>
        </div>
      </section>

      <section class="preview-section">
        <div class="preview-header">预览:</div>
        <div class="preview-container">
          <div class="preview-box">
            <div class="preview-label">原图</div>
            <canvas id="originalCanvas"></canvas>
          </div>
          <div class="preview-box">
            <div class="preview-label">处理后</div>
            <canvas id="resultCanvas"></canvas>
          </div>
        </div>
        <div id="palettePreview" class="palette-preview"></div>
      </section>
    </main>

    <footer class="footer">
      <span>Retro Pixelizer - 像素化艺术处理器</span>
    </footer>
  </div>

  <script>
(() => {
  "use strict";

  // DOM Elements
  const fileInput = document.getElementById("fileInput");
  const uploadArea = document.getElementById("uploadArea");
  const targetWidthInput = document.getElementById("targetWidth");
  const targetWidthNumber = document.getElementById("targetWidthNumber");
  const widthValue = document.getElementById("widthValue");
  const ditherButtons = document.getElementById("ditherButtons");
  const paletteButtons = document.getElementById("paletteButtons");
  const paletteFileInput = document.getElementById("paletteFile");
  const customPaletteGroup = document.getElementById("customPaletteGroup");
  const downloadBtn = document.getElementById("downloadBtn");
  const statusEl = document.getElementById("status");
  const themeToggle = document.getElementById("themeToggle");
  const originalCanvas = document.getElementById("originalCanvas");
  const resultCanvas = document.getElementById("resultCanvas");
  const palettePreview = document.getElementById("palettePreview");

  // State
  let originalImage = null;
  let currentPalette = null;
  let processedImageData = null;
  let processTimeout = null;
  let scaleFactor = 1;
  let currentDitherAlgo = "floyd-steinberg";

  // Built-in Palettes
  const BUILTIN_PALETTES = {
    "oil-6": {
      name: "Oil 6",
      colors: ["#fbf5ef", "#f2d3ab", "#c69fa5", "#8b6d9c", "#494d7e", "#272744"]
    },
    "slso8": {
      name: "SLSO8",
      colors: ["#0d2b45", "#203c56", "#544e68", "#8d697a", "#d08159", "#ffaa5e", "#ffd4a3", "#ffecd6"]
    },
    "blessing": {
      name: "Blessing",
      colors: ["#74569b", "#96fbc7", "#f7ffae", "#ffb3cb", "#d8bfd8"]
    },
    "nyx8": {
      name: "Nyx8",
      colors: ["#08141e", "#0f2a3f", "#20394f", "#f6d6bd", "#c3a38a", "#997577", "#816271", "#4e495f"]
    },
    "ammo-8": {
      name: "Ammo-8",
      colors: ["#040c06", "#112318", "#1e3a29", "#305d42", "#4d8061", "#89a257", "#bedc7f", "#eeffcc"]
    },
    "aap-64": {
      name: "AAP-64",
      colors: ["#060608", "#141013", "#3b1725", "#73172d", "#b4202a", "#df3e23", "#fa6a0a", "#f9a31b", "#ffd541", "#fffc40", "#d6f264", "#9cdb43", "#59c135", "#14a02e", "#1a7a3e", "#24523b", "#122020", "#143464", "#285cc4", "#249fde", "#20d6c7", "#a6fcdb", "#ffffff", "#fef3c0", "#fad6b8", "#f5a097", "#e86a73", "#bc4a9b", "#793a80", "#403353", "#242234", "#221c1a", "#322b28", "#71413b", "#bb7547", "#dba463", "#f4d29c", "#dae0ea", "#b3b9d1", "#8b93af", "#6d758d", "#4a5462", "#333941", "#422433", "#5b3138", "#8e5252", "#ba756a", "#e9b5a3", "#e3e6ff", "#b9bffb", "#849be4", "#588dbe", "#477d85", "#23674e", "#328464", "#5daf8d", "#92dcba", "#cdf7e2", "#e4d2aa", "#c7b08b", "#a08662", "#796755", "#5a4e44", "#423934"]
    },
    "dreamscape8": {
      name: "Dreamscape8",
      colors: ["#c9cca1", "#caa05a", "#ae6a47", "#8b4049", "#543344", "#515262", "#63787d", "#8ea091"]
    },
    "ink": {
      name: "Ink",
      colors: ["#1f1f29", "#413a42", "#596070", "#96a2b3", "#eaf0d8"]
    },
    "blk-nx64": {
      name: "BLK NX64",
      colors: ["#000000", "#12173d", "#293268", "#464b8c", "#6b74b2", "#909edd", "#c1d9f2", "#ffffff", "#a293c4", "#7b6aa5", "#53427f", "#3c2c68", "#431e66", "#5d2f8c", "#854cbf", "#b483ef", "#8cff9b", "#42bc7f", "#22896e", "#14665b", "#0f4a4c", "#0a2a33", "#1d1a59", "#322d89", "#354ab2", "#3e83d1", "#50b9eb", "#8cdaff", "#53a1ad", "#3b768f", "#21526b", "#163755", "#008782", "#00aaa5", "#27d3cb", "#78fae6", "#cdc599", "#988f64", "#5c5d41", "#353f23", "#919b45", "#afd370", "#ffe091", "#ffaa6e", "#ff695a", "#b23c40", "#ff6675", "#dd3745", "#a52639", "#721c2f", "#b22e69", "#e54286", "#ff6eaf", "#ffa5d5", "#ffd3ad", "#cc817a", "#895654", "#61393b", "#3f1f3c", "#723352", "#994c69", "#c37289", "#f29faa", "#ffccd0"]
    },
    "dream-haze-8": {
      name: "Dream Haze 8",
      colors: ["#3c42c4", "#6e51c8", "#a065cd", "#ce79d2", "#d68fb8", "#dda2a3", "#eac4ae", "#f4dfbe"]
    }
  };

  // Initialize
  function init() {
    loadSavedTheme();
    bindEvents();
    loadBuiltinPalette("oil-6");
  }

  function loadSavedTheme() {
    const savedTheme = localStorage.getItem("pixelizer_theme") || "light";
    setTheme(savedTheme);
  }

  function bindEvents() {
    themeToggle.addEventListener("click", toggleTheme);
    uploadArea.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", handleFileSelect);
    uploadArea.addEventListener("dragover", handleDragOver);
    uploadArea.addEventListener("dragleave", handleDragLeave);
    uploadArea.addEventListener("drop", handleDrop);

    targetWidthInput.addEventListener("input", () => {
      const value = targetWidthInput.value;
      targetWidthNumber.value = value;
      widthValue.textContent = `px`;
      triggerAutoProcess();
    });

    targetWidthNumber.addEventListener("input", () => {
      const value = Math.max(32, Math.min(512, parseInt(targetWidthNumber.value) || 128));
      targetWidthNumber.value = value;
      targetWidthInput.value = value;
      widthValue.textContent = `px`;
      triggerAutoProcess();
    });

    ditherButtons.addEventListener("click", (e) => {
      if (e.target.classList.contains("dither-btn")) {
        document.querySelectorAll(".dither-btn").forEach(btn => btn.classList.remove("active"));
        e.target.classList.add("active");
        currentDitherAlgo = e.target.dataset.algo;
        triggerAutoProcess();
      }
    });

    paletteButtons.addEventListener("click", (e) => {
      if (e.target.classList.contains("palette-btn")) {
        document.querySelectorAll(".palette-btn").forEach(btn => btn.classList.remove("active"));
        e.target.classList.add("active");

        const paletteKey = e.target.dataset.palette;
        if (paletteKey === "custom") {
          customPaletteGroup.style.display = "block";
          currentPalette = null;
          renderPalettePreview([]);
        } else {
          customPaletteGroup.style.display = "none";
          loadBuiltinPalette(paletteKey);
          triggerAutoProcess();
        }
      }
    });

    paletteFileInput.addEventListener("change", handleCustomPaletteUpload);
    downloadBtn.addEventListener("click", downloadResult);
  }

  function setTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    themeToggle.textContent = theme === "dark" ? "[亮色]" : "[暗色]";
    localStorage.setItem("pixelizer_theme", theme);
  }

  function toggleTheme() {
    const current = document.documentElement.getAttribute("data-theme");
    setTheme(current === "dark" ? "light" : "dark");
  }

  function setStatus(msg, isError = false) {
    statusEl.textContent = msg;
    statusEl.classList.toggle("error", isError);
  }

  function triggerAutoProcess() {
    if (!originalImage || !currentPalette) return;

    clearTimeout(processTimeout);
    processTimeout = setTimeout(() => {
      processImage();
    }, 300);
  }

  function handleDragOver(e) {
    e.preventDefault();
    uploadArea.classList.add("dragover");
  }

  function handleDragLeave(e) {
    e.preventDefault();
    uploadArea.classList.remove("dragover");
  }

  function handleDrop(e) {
    e.preventDefault();
    uploadArea.classList.remove("dragover");
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      loadImageFile(files[0]);
    }
  }

  function handleFileSelect(e) {
    const files = e.target.files;
    if (files.length > 0) {
      loadImageFile(files[0]);
    }
    e.target.value = '';
  }

  function loadImageFile(file) {
    if (!file.type.startsWith("image/")) {
      setStatus("请选择图片文件", true);
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const maxDimension = 2048;
        if (img.width > maxDimension || img.height > maxDimension) {
          const scale = Math.min(maxDimension / img.width, maxDimension / img.height);
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = Math.floor(img.width * scale);
          tempCanvas.height = Math.floor(img.height * scale);
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

          const resizedImg = new Image();
          resizedImg.onload = () => {
            originalImage = resizedImg;
            drawOriginalImage();
            downloadBtn.disabled = true;
            resultCanvas.width = 0;
            resultCanvas.height = 0;
            processedImageData = null;
            setStatus(`图片已加载 (已调整至${resizedImg.width}x${resizedImg.height})`);
            triggerAutoProcess();
          };
          resizedImg.src = tempCanvas.toDataURL();
        } else {
          originalImage = img;
          drawOriginalImage();
          downloadBtn.disabled = true;
          resultCanvas.width = 0;
          resultCanvas.height = 0;
          processedImageData = null;
          setStatus("图片已加载");
          triggerAutoProcess();
        }
      };
      img.onerror = () => {
        setStatus("图片加载失败", true);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  function drawOriginalImage() {
    if (!originalImage) return;

    const maxSize = 800;
    let width = originalImage.width;
    let height = originalImage.height;

    if (width > maxSize || height > maxSize) {
      const scale = Math.min(maxSize / width, maxSize / height);
      width = Math.floor(width * scale);
      height = Math.floor(height * scale);
    }

    originalCanvas.width = width;
    originalCanvas.height = height;

    const ctx = originalCanvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(originalImage, 0, 0, width, height);
  }

  function loadBuiltinPalette(key) {
    const palette = BUILTIN_PALETTES[key];
    if (palette) {
      currentPalette = hexArrayToRGB(palette.colors);
      renderPalettePreview(palette.colors);
      setStatus(`已加载: ${palette.name} (${palette.colors.length}色)`);
    }
  }

  function handleCustomPaletteUpload(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target.result;
      const colors = parsePaletteFile(content, file.name.toLowerCase());
      if (colors.length > 0) {
        currentPalette = hexArrayToRGB(colors);
        renderPalettePreview(colors);
        setStatus(`已加载自定义调色板 (${colors.length}色)`);
        triggerAutoProcess();
      } else {
        setStatus("调色板解析失败", true);
      }
    };
    reader.readAsText(file);
  }

  function parsePaletteFile(content, filename) {
    const colors = [];
    const lines = content.split("\n");

    if (filename.endsWith(".hex")) {
      for (const line of lines) {
        const hex = line.trim();
        if (/^#?[0-9A-Fa-f]{6}$/.test(hex)) {
          colors.push(hex.startsWith("#") ? hex : `#${hex}`);
        }
      }
    } else if (filename.endsWith(".gpl")) {
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith("#") || trimmed === "") continue;
        if (trimmed.startsWith("GIMP Palette")) continue;
        if (trimmed.startsWith("Name:") || trimmed.startsWith("Columns:")) continue;

        const parts = trimmed.split(/\s+/);
        if (parts.length >= 3) {
          const r = parseInt(parts[0]);
          const g = parseInt(parts[1]);
          const b = parseInt(parts[2]);
          if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
            colors.push(rgbToHex(r, g, b));
          }
        }
      }
    }

    return [...new Set(colors)];
  }

  function hexArrayToRGB(hexArray) {
    return hexArray.map(hex => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    });
  }

  function rgbToHex(r, g, b) {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
  }

  function renderPalettePreview(hexArray) {
    palettePreview.innerHTML = "";
    hexArray.forEach(hex => {
      const div = document.createElement("div");
      div.className = "palette-color";
      div.style.backgroundColor = hex;
      div.setAttribute("data-hex", hex);
      palettePreview.appendChild(div);
    });
  }

  function processImage() {
    if (!originalImage || !currentPalette) {
      setStatus("请先加载图片和调色板", true);
      return;
    }

    setStatus("处理中...");

    setTimeout(() => {
      try {
        const targetWidth = parseInt(targetWidthInput.value);
        const ditherAlgo = currentDitherAlgo;

        const result = pixelizeImage(originalImage, targetWidth, currentPalette, ditherAlgo);

        processedImageData = result;
        scaleFactor = result.scaleFactor;

        const displayCanvas = document.createElement("canvas");
        displayCanvas.width = result.width;
        displayCanvas.height = result.height;
        const displayCtx = displayCanvas.getContext("2d");
        displayCtx.putImageData(result.imageData, 0, 0);

        const maxSize = 800;
        let displayWidth = result.width;
        let displayHeight = result.height;

        if (displayWidth > maxSize || displayHeight > maxSize) {
          const scale = Math.min(maxSize / displayWidth, maxSize / displayHeight);
          displayWidth = Math.floor(displayWidth * scale);
          displayHeight = Math.floor(displayHeight * scale);
        }

        resultCanvas.width = displayWidth;
        resultCanvas.height = displayHeight;
        const ctx = resultCanvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(displayCanvas, 0, 0, displayWidth, displayHeight);

        downloadBtn.disabled = false;
        setStatus("处理完成!");
      } catch (error) {
        setStatus(`处理失败: ${error.message}`, true);
      }
    }, 50);
  }

  function pixelizeImage(img, targetWidth, palette, ditherAlgo) {
    const aspectRatio = img.height / img.width;
    const targetHeight = Math.round(targetWidth * aspectRatio);

    const maxPixels = 1024 * 1024;
    if (targetWidth * targetHeight > maxPixels) {
      throw new Error(`目标分辨率过大 (${targetWidth}x${targetHeight})，请降低宽度`);
    }

    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = targetWidth;
    tempCanvas.height = targetHeight;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.imageSmoothingEnabled = false;
    tempCtx.drawImage(img, 0, 0, targetWidth, targetHeight);

    const imageData = tempCtx.getImageData(0, 0, targetWidth, targetHeight);

    applyDithering(imageData, palette, ditherAlgo);

    const scaleFactor = Math.max(1, Math.floor(img.width / targetWidth));
    const scaledWidth = targetWidth * scaleFactor;
    const scaledHeight = targetHeight * scaleFactor;

    const scaledCanvas = document.createElement("canvas");
    scaledCanvas.width = scaledWidth;
    scaledCanvas.height = scaledHeight;
    const scaledCtx = scaledCanvas.getContext("2d");
    scaledCtx.imageSmoothingEnabled = false;

    tempCanvas.width = targetWidth;
    tempCanvas.height = targetHeight;
    tempCtx.putImageData(imageData, 0, 0);

    scaledCtx.drawImage(tempCanvas, 0, 0, targetWidth, targetHeight, 0, 0, scaledWidth, scaledHeight);

    const scaledImageData = scaledCtx.getImageData(0, 0, scaledWidth, scaledHeight);

    return {
      imageData: scaledImageData,
      width: scaledWidth,
      height: scaledHeight,
      scaleFactor: scaleFactor
    };
  }

  function applyDithering(imageData, palette, algo) {
    const { width, height, data } = imageData;

    if (algo === "none") {
      for (let i = 0; i < data.length; i += 4) {
        const nearest = findNearestColor({ r: data[i], g: data[i + 1], b: data[i + 2] }, palette);
        data[i] = nearest.r;
        data[i + 1] = nearest.g;
        data[i + 2] = nearest.b;
      }
    } else if (algo === "bayer-4x4") {
      bayerDither4(imageData, palette);
    } else if (algo === "bayer-8x8") {
      bayerDither8(imageData, palette);
    } else if (algo === "random") {
      randomDither(imageData, palette);
    } else if (algo === "floyd-steinberg") {
      floydSteinbergDither(imageData, palette);
    }
  }

  function floydSteinbergDither(imageData, palette) {
    const { width, height, data } = imageData;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = (y * width + x) * 4;
        const oldColor = { r: data[i], g: data[i + 1], b: data[i + 2] };
        const newColor = findNearestColor(oldColor, palette);

        data[i] = newColor.r;
        data[i + 1] = newColor.g;
        data[i + 2] = newColor.b;

        const errorR = oldColor.r - newColor.r;
        const errorG = oldColor.g - newColor.g;
        const errorB = oldColor.b - newColor.b;

        if (x + 1 < width) {
          const ni = i + 4;
          data[ni] = clamp(data[ni] + errorR * 7/16);
          data[ni + 1] = clamp(data[ni + 1] + errorG * 7/16);
          data[ni + 2] = clamp(data[ni + 2] + errorB * 7/16);
        }

        if (y + 1 < height) {
          if (x > 0) {
            const ni = i + width * 4 - 4;
            data[ni] = clamp(data[ni] + errorR * 3/16);
            data[ni + 1] = clamp(data[ni + 1] + errorG * 3/16);
            data[ni + 2] = clamp(data[ni + 2] + errorB * 3/16);
          }

          const ni2 = i + width * 4;
          data[ni2] = clamp(data[ni2] + errorR * 5/16);
          data[ni2 + 1] = clamp(data[ni2 + 1] + errorG * 5/16);
          data[ni2 + 2] = clamp(data[ni2 + 2] + errorB * 5/16);

          if (x + 1 < width) {
            const ni3 = i + width * 4 + 4;
            data[ni3] = clamp(data[ni3] + errorR * 1/16);
            data[ni3 + 1] = clamp(data[ni3 + 1] + errorG * 1/16);
            data[ni3 + 2] = clamp(data[ni3 + 2] + errorB * 1/16);
          }
        }
      }
    }
  }

  function bayerDither4(imageData, palette) {
    const { width, height, data } = imageData;
    const matrix = BAYER_4X4;
    const n = 4;
    const denom = n * n;

    const paletteStep = palette.length <= 1 ? 255 : getAverageColorDistance(palette);
    const strength = paletteStep;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = (y * width + x) * 4;
        const threshold = ((matrix[y % n][x % n] + 0.5) / denom - 0.5) * strength;

        const r = clamp(data[i] + threshold);
        const g = clamp(data[i + 1] + threshold);
        const b = clamp(data[i + 2] + threshold);

        const nearest = findNearestColor({ r, g, b }, palette);
        data[i] = nearest.r;
        data[i + 1] = nearest.g;
        data[i + 2] = nearest.b;
      }
    }
  }

  function bayerDither8(imageData, palette) {
    const { width, height, data } = imageData;
    const matrix = BAYER_8X8;
    const n = 8;
    const denom = n * n;

    const paletteStep = palette.length <= 1 ? 255 : getAverageColorDistance(palette);
    const strength = paletteStep;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = (y * width + x) * 4;
        const threshold = ((matrix[y % n][x % n] + 0.5) / denom - 0.5) * strength;

        const r = clamp(data[i] + threshold);
        const g = clamp(data[i + 1] + threshold);
        const b = clamp(data[i + 2] + threshold);

        const nearest = findNearestColor({ r, g, b }, palette);
        data[i] = nearest.r;
        data[i + 1] = nearest.g;
        data[i + 2] = nearest.b;
      }
    }
  }

  function randomDither(imageData, palette) {
    const { width, height, data } = imageData;
    const paletteStep = palette.length <= 1 ? 255 : getAverageColorDistance(palette);
    const amp = paletteStep * 0.6;

    for (let i = 0; i < data.length; i += 4) {
      const noiseR = (Math.random() - 0.5) * amp;
      const noiseG = (Math.random() - 0.5) * amp;
      const noiseB = (Math.random() - 0.5) * amp;

      const r = clamp(data[i] + noiseR);
      const g = clamp(data[i + 1] + noiseG);
      const b = clamp(data[i + 2] + noiseB);

      const nearest = findNearestColor({ r, g, b }, palette);
      data[i] = nearest.r;
      data[i + 1] = nearest.g;
      data[i + 2] = nearest.b;
    }
  }

  function getAverageColorDistance(palette) {
    if (palette.length <= 1) return 255;

    let totalDist = 0;
    let count = 0;

    for (let i = 0; i < palette.length - 1; i++) {
      const c1 = palette[i];
      const c2 = palette[i + 1];
      const dr = c1.r - c2.r;
      const dg = c1.g - c2.g;
      const db = c1.b - c2.b;
      totalDist += Math.sqrt(dr * dr + dg * dg + db * db);
      count++;
    }

    return count > 0 ? totalDist / count : 255;
  }

  const BAYER_4X4 = [
    [0, 8, 2, 10],
    [12, 4, 14, 6],
    [3, 11, 1, 9],
    [15, 7, 13, 5]
  ];

  const BAYER_8X8 = [
    [0, 48, 12, 60, 3, 51, 15, 63],
    [32, 16, 44, 28, 35, 19, 47, 31],
    [8, 56, 4, 52, 11, 59, 7, 55],
    [40, 24, 36, 20, 43, 27, 39, 23],
    [2, 50, 14, 62, 1, 49, 13, 61],
    [34, 18, 46, 30, 33, 17, 45, 29],
    [10, 58, 6, 54, 9, 57, 5, 53],
    [42, 26, 38, 22, 41, 25, 37, 21]
  ];

  function findNearestColor(color, palette) {
    let minDistance = Infinity;
    let nearest = palette[0];

    for (const paletteColor of palette) {
      const distance = colorDistance(color, paletteColor);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = paletteColor;
      }
    }

    return nearest;
  }

  function colorDistance(c1, c2) {
    const rmean = (c1.r + c2.r) / 2;
    const dr = c1.r - c2.r;
    const dg = c1.g - c2.g;
    const db = c1.b - c2.b;
    return (2 + rmean/256) * dr * dr + 4 * dg * dg + (2 + (255-rmean)/256) * db * db;
  }

  function clamp(value) {
    return Math.max(0, Math.min(255, Math.round(value)));
  }

  function downloadResult() {
    if (!processedImageData) return;

    const downloadCanvas = document.createElement("canvas");
    downloadCanvas.width = processedImageData.width;
    downloadCanvas.height = processedImageData.height;
    const ctx = downloadCanvas.getContext("2d");
    ctx.putImageData(processedImageData.imageData, 0, 0);

    downloadCanvas.toBlob(async (blob) => {
      if (!blob) return;

      const fileName = `retro-pixelized-${processedImageData.width}x${processedImageData.height}-${Date.now()}.png`;

      if (navigator.share && navigator.canShare) {
        try {
          const file = new File([blob], fileName, { type: "image/png" });
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({
              files: [file],
              title: "Retro Pixel Image",
              text: "Created with Retro Pixelizer"
            });
            return;
          }
        } catch (err) {
          if (err.name !== "AbortError") console.warn("Share failed:", err);
        }
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.style.display = "none";
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();

      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }, "image/png");
  }

  init();
})();
  </script>
</body>
</html>
